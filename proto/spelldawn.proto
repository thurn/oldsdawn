// Copyright Â© Spelldawn 2021-present

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//    https://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package spelldawn;
option csharp_namespace = "Spelldawn.Protos";

import "google/protobuf/wrappers.proto";
import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";

// ============================================================================
// Masonry
// ============================================================================


enum FlexAlign {
    FLEX_ALIGN_UNSPECIFIED = 0;
    FLEX_ALIGN_AUTO = 1;
    FLEX_ALIGN_FLEX_START = 2;
    FLEX_ALIGN_CENTER = 3;
    FLEX_ALIGN_FLEX_END = 4;
    FLEX_ALIGN_STRETCH = 5;
}

enum FlexDisplayStyle {
    FLEX_DISPLAY_STYLE_UNSPECIFIED = 0;
    FLEX_DISPLAY_STYLE_FLEX = 1;
    FLEX_DISPLAY_STYLE_NONE = 2;
}

enum FlexDirection {
    FLEX_DIRECTION_UNSPECIFIED = 0;
    FLEX_DIRECTION_COLUMN = 1;
    FLEX_DIRECTION_COLUMN_REVERSE = 2;
    FLEX_DIRECTION_ROW = 3;
    FLEX_DIRECTION_ROW_REVERSE = 4;
}

enum FlexWrap {
    FLEX_WRAP_UNSPECIFIED = 0;
    FLEX_WRAP_NO_WRAP = 1;
    FLEX_WRAP_WRAP = 2;
    FLEX_WRAP_WRAP_REVERSE = 3;
}

enum FlexJustify {
    FLEX_JUSTIFY_UNSPECIFIED = 0;
    FLEX_JUSTIFY_FLEX_START = 1;
    FLEX_JUSTIFY_CENTER = 2;
    FLEX_JUSTIFY_FLEX_END = 3;
    FLEX_JUSTIFY_SPACE_BETWEEN = 4;
    FLEX_JUSTIFY_SPACE_AROUND = 5;
}

enum FlexOverflow {
    FLEX_OVERFLOW_UNSPECIFIED = 0;
    FLEX_OVERFLOW_VISIBLE = 1;
    FLEX_OVERFLOW_HIDDEN = 2;
}

enum FlexPosition {
    FLEX_POSITION_UNSPECIFIED = 0;
    FLEX_POSITION_RELATIVE = 1;
    FLEX_POSITION_ABSOLUTE = 2;
}

enum TextOverflow {
    TEXT_OVERFLOW_UNSPECIFIED = 0;
    TEXT_OVERFLOW_CLIP = 1;
    TEXT_OVERFLOW_ELLIPSIS = 2;
}

enum EasingMode {
    EASING_MODE_UNSPECIFIED = 0;
    EASING_MODE_EASE = 1;
    EASING_MODE_EASE_IN = 2;
    EASING_MODE_EASE_OUT = 3;
    EASING_MODE_EASE_IN_OUT = 4;
    EASING_MODE_LINEAR = 5;
    EASING_MODE_EASE_IN_SINE = 6;
    EASING_MODE_EASE_OUT_SINE = 7;
    EASING_MODE_EASE_IN_OUT_SINE = 8;
    EASING_MODE_EASE_IN_CUBIC = 9;
    EASING_MODE_EASE_OUT_CUBIC = 10;
    EASING_MODE_EASE_IN_OUT_CUBIC = 11;
    EASING_MODE_EASE_IN_CIRC = 12;
    EASING_MODE_EASE_OUT_CIRC = 13;
    EASING_MODE_EASE_IN_OUT_CIRC = 14;
    EASING_MODE_EASE_IN_ELASTIC = 15;
    EASING_MODE_EASE_OUT_ELASTIC = 16;
    EASING_MODE_EASE_IN_OUT_ELASTIC = 17;
    EASING_MODE_EASE_IN_BACK = 18;
    EASING_MODE_EASE_OUT_BACK = 19;
    EASING_MODE_EASE_IN_OUT_BACK = 20;
    EASING_MODE_EASE_IN_BOUNCE = 21;
    EASING_MODE_EASE_OUT_BOUNCE = 22;
    EASING_MODE_EASE_IN_OUT_BOUNCE = 23;
}

enum ImageScaleMode {
    IMAGE_SCALE_MODE_UNSPECIFIED = 0;
    IMAGE_SCALE_MODE_STRETCH_TO_FILL = 1;
    IMAGE_SCALE_MODE_SCALE_AND_CROP = 2;
    IMAGE_SCALE_MODE_SCALE_TO_FIT = 3;
}

enum FontStyle {
    FONT_STYLE_UNSPECIFIED = 0;
    FONT_STYLE_NORMAL = 1;
    FONT_STYLE_BOLD = 2;
    FONT_STYLE_ITALIC = 3;
    FONT_STYLE_BOLD_AND_ITALIC = 4;
}

enum OverflowClipBox {
    OVERFLOW_CLIP_BOX_UNSPECIFIED = 0;
    OVERFLOW_CLIP_BOX_PADDING_BOX = 1;
    OVERFLOW_CLIP_BOX_CONTENT_BOX = 2;
}

enum TextAlign {
    TEXT_ALIGN_UNSPECIFIED = 0;
    TEXT_ALIGN_UPPER_LEFT = 1;
    TEXT_ALIGN_UPPER_CENTER = 2;
    TEXT_ALIGN_UPPER_RIGHT = 3;
    TEXT_ALIGN_MIDDLE_LEFT = 4;
    TEXT_ALIGN_MIDDLE_CENTER = 5;
    TEXT_ALIGN_MIDDLE_RIGHT = 6;
    TEXT_ALIGN_LOWER_LEFT = 7;
    TEXT_ALIGN_LOWER_CENTER = 8;
    TEXT_ALIGN_LOWER_RIGHT = 9;
}

enum TextOverflowPosition {
    TEXT_OVERFLOW_POSITION_UNSPECIFIED = 0;
    TEXT_OVERFLOW_POSITION_END = 1;
    TEXT_OVERFLOW_POSITION_START = 2;
    TEXT_OVERFLOW_POSITION_MIDDLE = 3;
}

enum FlexVisibility {
    FLEX_VISIBILITY_UNSPECIFIED = 0;
    FLEX_VISIBILITY_VISIBLE = 1;
    FLEX_VISIBILITY_HIDDEN = 2;
}

enum WhiteSpace {
    WHITE_SPACE_UNSPECIFIED = 0;
    WHITE_SPACE_NORMAL = 1;
    WHITE_SPACE_NO_WRAP = 2;
}

message FlexColor {
    /* Red color component, specified in the range 0.0 to 1.0 inclusive. */
    float red = 1;

    /* Green color component, specified in the range 0.0 to 1.0 inclusive. */
    float green = 2;

    /* Blue color component, specified in the range 0.0 to 1.0 inclusive. */
    float blue = 3;

    /*
     * Alpha color component, specified in the range 0.0 (transparent) to 1.0
     * (opaque) inclusive.
     */
    float alpha = 4;
}

message SpriteAddress {
    string address = 1;
}

message FontAddress {
    string address = 1;
}

message ProjectileAddress {
    string address = 1;
}

message EffectAddress {
    string address = 1;
}

message AudioClipAddress {
    string address = 1;
}

message FlexVector2 {
    float x = 1;
    float y = 2;
}

message FlexVector3 {
    float x = 1;
    float y = 2;
    float z = 3;
}

enum DimensionUnit {
    DIMENSION_UNIT_UNSPECIFIED = 0;
    // Measurement in Pixels.
    // This is Unity density-independent pixels, not real physical pixels.
    DIMENSION_UNIT_PIXELS = 1;
    // Percentage of parent container
    DIMENSION_UNIT_PERCENTAGE = 2;
}

message Dimension {
    DimensionUnit unit = 1;
    float value = 2;
}

message DimensionGroup {
    Dimension top = 1;
    Dimension right = 2;
    Dimension bottom = 3;
    Dimension left = 4;
}

message BorderWidth {
    float top = 1;
    float right = 2;
    float bottom = 3;
    float left = 4;
}

message BorderColor {
    FlexColor top = 1;
    FlexColor right = 2;
    FlexColor bottom = 3;
    FlexColor left = 4;
}

message BorderRadius {
    Dimension top_left = 1;
    Dimension top_right = 2;
    Dimension bottom_right = 3;
    Dimension bottom_left = 4;
}

message FlexRotate {
    float degrees = 1;
}

message FlexTranslate {
    Dimension x = 1;
    Dimension y = 2;
    float z = 3;
}

message FlexScale {
    FlexVector3 amount = 1;
}

message TextShadow {
    FlexVector2 offset = 1;
    float blur_radius = 2;
    FlexColor color = 3;
}

message TimeValue {
    uint32 milliseconds = 1;
}

message ImageSlice {
    uint32 top = 1;
    uint32 right = 2;
    uint32 bottom = 3;
    uint32 left = 4;
}

// Controls whether elements respond to interface events.
enum FlexPickingMode {
    // Unspecified, currently identical to 'position'.
    FLEX_PICKING_MODE_UNSPECIFIED = 0;
    // Picking enabled, events will be recognized.
    FLEX_PICKING_MODE_POSITION = 1;
    // Picking disabled, events ignored.
    FLEX_PICKING_MODE_IGNORE = 2;
}

message FlexStyle {
    FlexAlign align_content = 1;
    FlexAlign align_items = 2;
    FlexAlign align_self = 3;
    FlexColor background_color = 4;
    SpriteAddress background_image = 5;
    BorderColor border_color = 6;
    BorderRadius border_radius = 7;
    BorderWidth border_width = 8;
    DimensionGroup inset = 9;
    FlexColor color = 10;
    FlexDisplayStyle display = 11;
    Dimension flex_basis = 12;
    FlexDirection flex_direction = 13;
    google.protobuf.FloatValue flex_grow = 14;
    google.protobuf.FloatValue flex_shrink = 15;
    FlexWrap wrap = 16;
    Dimension font_size = 17;
    Dimension height = 18;
    FlexJustify justify_content = 19;
    Dimension letter_spacing = 20;
    DimensionGroup margin = 21;
    Dimension max_height = 22;
    Dimension max_width = 23;
    Dimension min_height = 24;
    Dimension min_width = 25;
    google.protobuf.FloatValue opacity = 26;
    FlexOverflow overflow = 27;
    DimensionGroup padding = 28;
    FlexPosition position = 29;
    FlexRotate rotate = 30;
    FlexScale scale = 31;
    TextOverflow text_overflow = 32;
    TextShadow text_shadow = 33;
    FlexTranslate transform_origin = 34;
    repeated TimeValue transition_delays = 35;
    repeated TimeValue transition_durations = 36;
    repeated string transition_properties = 37;
    repeated EasingMode transition_easing_modes = 38;
    FlexTranslate translate = 39;
    FlexColor background_image_tint_color = 40;
    ImageScaleMode background_image_scale_mode = 41;
    FontAddress font = 42;
    FontStyle font_style = 43;
    OverflowClipBox overflow_clip_box = 44;
    Dimension paragraph_spacing = 45;
    ImageSlice image_slice = 46;
    TextAlign text_align = 47;
    FlexColor text_outline_color = 48;
    google.protobuf.FloatValue text_outline_width = 49;
    TextOverflowPosition text_overflow_position = 50;
    FlexVisibility visibility = 51;
    WhiteSpace white_space = 52;
    Dimension width = 53;
    Dimension word_spacing = 54;

    /*
    * Overwrites both 'width' and 'height' by multiplying the dimensions of
    * the provided 'background_image' (in units of raw pixels) by this
    * constant.
    */
    google.protobuf.FloatValue background_image_scale_multiplier = 55;

    /*
    * Calculates the aspect ratio of the provided 'background_image' and uses
    * it to set dimensions. If 'width' is set, the 'height' will be set based
    * on the aspect ratio and vice versa. Does not support percentage values.
    */
    bool fixed_background_image_aspect_ratio = 56;

    FlexPickingMode picking_mode = 57;
}

message Flexbox {
}

message Text {
    string label = 1;
}

message EventHandlers {
    GameAction on_click = 1;
}

message NodeType {
    oneof node_type {
        Text text = 1;
    }
}

message Node {
    /*
    * Used to identify this node in the hierarchy, should be unique among
    * siblings. If not provided, index will be used instead.
    */
    string id = 1;

    /*
    * Used to identify this node in debugging tools
    */
    string name = 2;

    NodeType node_type = 3;

    repeated Node children = 4;

    EventHandlers event_handlers = 5;

    FlexStyle style = 6;
    FlexStyle hover_style = 7;
    FlexStyle pressed_style = 8;
}


// ============================================================================
// Game Primitives
// ============================================================================

message PlayerIdentifier {
    uint64 value = 1;
}

message GameIdentifier {
    uint64 value = 1;
}

enum PlayerSide {
    PLAYER_SIDE_UNSPECIFIED = 0;
    PLAYER_SIDE_OVERLORD = 1;
    PLAYER_SIDE_CHAMPION = 2;
}

enum PlayerName {
    PLAYER_NAME_UNSPECIFIED = 0;
    PLAYER_NAME_USER = 1;
    PLAYER_NAME_OPPONENT = 2;
}

message CardIdentifier {
    PlayerSide side = 1;
    uint32 index = 2;

    // Optionally, identifies a specific ability within a logical card which
    // is represented by this displayed card.
    google.protobuf.UInt32Value ability_id = 3;
}

message GameObjectIdentifier {
    oneof id {
        CardIdentifier card_id = 1;
        PlayerName identity = 2;
        PlayerName deck = 3;
        PlayerName discard_pile = 4;
    }
}

enum RoomIdentifier {
    ROOM_IDENTIFIER_UNSPECIFIED = 0;
    ROOM_IDENTIFIER_VAULT = 1;
    ROOM_IDENTIFIER_SANCTUM = 2;
    ROOM_IDENTIFIER_CRYPTS = 3;
    ROOM_IDENTIFIER_ROOM_A = 4;
    ROOM_IDENTIFIER_ROOM_B = 5;
    ROOM_IDENTIFIER_ROOM_C = 6;
    ROOM_IDENTIFIER_ROOM_D = 7;
    ROOM_IDENTIFIER_ROOM_E = 8;
}


// ============================================================================
// Game View
// ============================================================================


message CardIcon {
    /**
     * Whether to show this icon.
     *
     * This is needed to help the client differentiate between a null icon,
     * which it interprets as "don't change anything" and a icon which should
     * explicitly be removed.
     */
    bool enabled = 1;
    /* Background for the icon. */
    SpriteAddress background = 2;
    /* Text to display on the icon. */
    google.protobuf.StringValue text = 3;
    /* Scale multiplier for the background image. */
    google.protobuf.FloatValue background_scale = 4;
}

message CardIcons {
    CardIcon top_left_icon = 1;
    CardIcon top_right_icon = 2;
    CardIcon bottom_right_icon = 3;
    CardIcon bottom_left_icon = 4;
    CardIcon arena_icon = 5;
}

message CardTitle {
    string text = 1;
}

message RulesText {
    string text = 1;
}

enum TargetingArrow {
    TARGETING_ARROW_UNSPECIFIED = 0;
    TARGETING_ARROW_RED = 1;
    TARGETING_ARROW_BLUE = 2;
    TARGETING_ARROW_GREEN = 3;
}

// Card has no targeting requirement
message NoTargeting {
    // True if this card can currently be played
    bool can_play = 1;
}

// This card should prompt for a room to be played into.
message PlayInRoom {
    // The card can be played if at least one identifier is present here
    repeated RoomIdentifier valid_rooms = 1;
}

// The card should show an arrow to select a room to target
message ArrowTargetRoom {
    // The card can be played if at least one identifier is present here
    repeated RoomIdentifier valid_rooms = 1;

    // Which arrow to show
    TargetingArrow arrow = 2;
}

message CardTargeting {
    oneof targeting {
        NoTargeting no_targeting = 1;
        PlayInRoom play_in_room = 2;
        ArrowTargetRoom arrow_target_room = 3;
    }
}

message ObjectPositionOffscreen {
}

enum ClientRoomLocation {
    CLIENT_ROOM_LOCATION_UNSPECIFIED = 0;
    CLIENT_ROOM_LOCATION_BACK = 1;
    CLIENT_ROOM_LOCATION_FRONT = 2;
}

message ObjectPositionRoom {
    RoomIdentifier room_id = 1;
    ClientRoomLocation room_location = 2;
}

enum ClientItemLocation {
    CLIENT_ITEM_LOCATION_UNSPECIFIED = 0;
    CLIENT_ITEM_LOCATION_LEFT = 1;
    CLIENT_ITEM_LOCATION_RIGHT = 2;
}

message ObjectPositionItem {
    ClientItemLocation item_location = 1;
}

message ObjectPositionStaging {
}

message ObjectPositionHand {
    PlayerName owner = 1;
}

message ObjectPositionDeck {
    PlayerName owner = 1;
}

message ObjectPositionDeckContainer {
    PlayerName owner = 1;
}

message ObjectPositionDiscardPile {
    PlayerName owner = 1;
}

message ObjectPositionDiscardPileContainer {
    PlayerName owner = 1;
}

/*
 * Large display of cards *while* the score animation is playing. After the
 * score animation finishes, scored cards move to 'Identity' position.
 */
message ObjectPositionScoreAnimation {
}

message ObjectPositionRaid {
}

message ObjectPositionBrowser {
}

message ObjectPositionIdentity {
    PlayerName owner = 1;
}

message ObjectPositionIdentityContainer {
    PlayerName owner = 1;
}

message ObjectPositionRewardChest {
}

/// An object position which represents moving into a given card.
message ObjectPositionIntoCard {
    CardIdentifier card_id = 1;
}

message ObjectPosition {
    /*
     * A key by which to sort this object -- objects with higher sorting keys
     * should be displayed 'on top of' or 'in front of' objects with lower
     * sorting keys. In the case of ties, any ordering is acceptable.
     */
    uint32 sorting_key = 1;

    oneof position {
        ObjectPositionOffscreen offscreen = 2;
        ObjectPositionRoom room = 3;
        ObjectPositionItem item = 4;
        ObjectPositionStaging staging = 5;
        ObjectPositionHand hand = 6;
        ObjectPositionDeck deck = 7;
        ObjectPositionDeckContainer deck_container = 8;
        ObjectPositionDiscardPile discard_pile = 9;
        ObjectPositionDiscardPileContainer discard_pile_container = 10;
        ObjectPositionScoreAnimation score_animation = 11;
        ObjectPositionRaid raid = 12;
        ObjectPositionBrowser browser = 13;
        ObjectPositionIdentity identity = 14;
        ObjectPositionIdentityContainer identity_container = 15;
        ObjectPositionIntoCard into_card = 16;
    }
}

message RevealedCardView {
    SpriteAddress card_frame = 1;
    SpriteAddress title_background = 2;
    SpriteAddress jewel = 3;
    SpriteAddress image = 4;
    CardTitle title = 5;
    RulesText rules_text = 6;

    /*
    * Custom targeting behavior for a card. If unspecified, no targeting UI
    * is shown.
    */
    CardTargeting targeting = 7;

    /*
    * Where to move a played card. Information from 'targeting' will be
    * incorporated to fill this in, e.g. if a room is targeted and
    * ObjectPositionRoom is selected here with no RoomId, the targeted room
    * is used.
    */
    ObjectPosition on_release_position = 8;

    /*
     * Additional interface element rendered to the side of the card during an
     * info zoom.
     */
    Node supplemental_info = 9;
}

enum CardPrefab {
    CARD_PREFAB_UNSPECIFIED = 0;
    CARD_PREFAB_STANDARD = 1;
    CARD_PREFAB_TOKEN_CARD = 2;
}

message CardView {
    CardIdentifier card_id = 1;

    // Which prefab to use for this card, controls the overall appearance
    CardPrefab prefab = 2;

    // Whether the current user is able to see the front of this card.
    bool revealed_to_viewer = 3;

    // Whether the card is in the 'face up' state.
    bool is_face_up = 4;

    CardIcons card_icons = 5;

    SpriteAddress arena_frame = 6;

    // Used to e.g. determine which card back to display for this card.
    PlayerName owning_player = 7;

    // Card information which is only present on revealed cards.
    RevealedCardView revealed_card = 8;
}

message HandView {
    repeated CardView cards = 1;
}

message DiscardPileView {
    repeated CardView cards = 1;
}

message PlayerInfo {
    google.protobuf.StringValue name = 1;
    SpriteAddress portrait = 2;
    SpriteAddress portrait_frame = 3;
    repeated RoomIdentifier valid_rooms_to_visit = 4;

    // Card back asset to use for this player's cards.
    SpriteAddress card_back = 5;
}

message ManaView {
    uint32 base_mana = 1;

    // Additional mana with custom use restrictions.
    uint32 bonus_mana = 2;
}

message ScoreView {
    uint32 score = 1;
}

message RoomView {
    RoomIdentifier room_id = 1;
    repeated CardView back_cards = 2;
    repeated CardView front_cards = 3;
}

message ActionTrackerView {
    uint32 available_action_count = 1;
}

message DeckView {
    repeated CardView top_cards = 1;
}

message PlayerView {
    PlayerSide side = 1;
    PlayerInfo player_info = 2;
    ScoreView score = 3;
    ManaView mana = 4;
    ActionTrackerView action_tracker = 5;

    // Whether this player is currently able to take a game action
    bool can_take_action = 6;
}

message GameView {
    GameIdentifier game_id = 1;
    PlayerView user = 2;
    PlayerView opponent = 3;

    // Whether a raid is currently active. If true, the raid overlay will be
    // displayed, the raid music will be played, etc.
    bool raid_active = 4;
}


// ============================================================================
// Actions
// ============================================================================

message StandardAction {
    /** Opaque payload to send to the server when invoked. */
    bytes payload = 1;

    /* Immediate optimistic mutations to game state for this action. */
    CommandList update = 2;

    /* Temporary payload for use in testing. */
    google.protobuf.Any debug_payload = 3;
}

/*
* Spend an action to gain 1 mana.
*
* Optimistic: Mana is added immediately.
*/
message GainManaAction {
}

/*
* Spend an action to draw a card.
*
* Optimistic: Face-down card animates to reveal area.
*/
message DrawCardAction {
}

/*
* Spend an action to level up a room.
*
* Optimistic: Counter is added immediately
*/
message LevelUpRoomAction {
    RoomIdentifier room_id = 1;
}

message CardTarget {
    oneof card_target {
        RoomIdentifier room_id = 1;
    }
}

/*
* Spend an action to play a card from hand.
*
* Optimistic:
*   - Mana and action cost is spent immediately, and 'can play' values for
*     other cards in hand are optimistically updated
*   - Other costs like 'sacrifice an artifact' are not optimistic and are
*     handled like choices
*   - Targeted cards select their *first* valid target (cards, rooms, players)
*     optimistically. If additional targets are required, they're not handled
*     optimistically, and this play pattern should possibly be avoided.
*   - Cards that require a choice to be made before resolving do not display
*     the options optimistically, instead they animate to the reveal card area
*   - Item cards which don't require a choice to be made or target simply
*     animate into the play area optimistically
*   - Spell cards animate to the reveal card area and wait for their effects to
*     be applied
*   - Minion and Project cards animate to their selected room optimistically
*/
message PlayCardAction {
    CardIdentifier card_id = 1;
    CardTarget target = 2;
}

/*
* Spend an action to initiate a raid on one of the overlord's rooms
*
* Optimistic: Raid start animation plays
*/
message InitiateRaidAction {
    RoomIdentifier room_id = 1;
}

// Open or close a given interface panel.
//
// Behavior:
//   - Open: If the panel with this address has already been downloaded, it
//   is opened immediately. The server returns an updated view of the
//   panel contents.
//   - Close: The panel is closed immediately. No server response is
//   provided.
message TogglePanelAction {
    PanelAddress panel_address = 1;
    // Should the panel be opened or closed?
    bool open = 2;
}

// Test/debug options for creating a game
message CreateGameDebugOptions {
    // If true, all game events will be non-random.
    bool deterministic = 1;

    // Force the created game to use a specific identifier
    GameIdentifier override_game_identifier = 2;

    // If true, this game's state will be stored in memory instead of being
    // written to disk.
    bool in_memory = 3;

    // If true, an AI agent opponent is selected for this game.
    bool vs_agent = 4;
}

message CreateNewGameAction {
    PlayerSide side = 1;

    PlayerIdentifier opponent_id = 2;

    CreateGameDebugOptions debug_options = 3;
}

// Action to spend an action point with no other effect, typically used for
// tests
message SpendActionPointAction {}

// Possible game actions taken by the user.
//
// Actions have an associated 'optimistic' behavior to display while waiting
// for a server response. The client should not send multiple actions at the
// same time -- interaction should be disabled while an action is pending.
message GameAction {
    oneof action {
        StandardAction standard_action = 1;
        TogglePanelAction toggle_panel = 2;
        CreateNewGameAction create_new_game = 3;
        GainManaAction gain_mana = 4;
        DrawCardAction draw_card = 5;
        PlayCardAction play_card = 6;
        LevelUpRoomAction level_up_room = 7;
        InitiateRaidAction initiate_raid = 8;
        SpendActionPointAction spend_action_point = 9;
    }
}

// Initiate a play session. If a game_id is provided, connects to an ongoing
// game. Otherwise, creates a new game. This must be sent from an empty game
// scene.
message ConnectRequest {
    //Target game to connect to
    GameIdentifier game_id = 1;

    // User making this request.
    PlayerIdentifier player_id = 2;
}

message GameRequest {
    GameAction action = 1;

    // Current game_id, if a game is currently ongoing.
    GameIdentifier game_id = 2;

    // Identifies the user making this request. At some point I'm going to
    // figure out how to set up authentication, but currently we operate on
    // the honor system :)
    PlayerIdentifier player_id = 3;
}

// ============================================================================
// Commands
// ============================================================================

message DebugLogCommand {
    string message = 1;
}

/*
 * Run a series of command lists simultaneously. Warning: applying multiple
 * commands to the same game object will have unpredictable results.
 */
message RunInParallelCommand {
    repeated CommandList commands = 1;
}

/* Wait before executing the next command in sequence. */
message DelayCommand {
    TimeValue duration = 1;
}

// Instructs the client to load a given scene and then connect to the indicated
// game.
message ConnectToGameCommand {
    GameIdentifier game_id = 1;
    string scene_name = 2;
}

enum PanelAddress {
    PANEL_ADDRESS_UNSPECIFIED = 0;
    PANEL_ADDRESS_DEBUG_PANEL = 1;
}

message InterfacePanel {
    PanelAddress address = 1;
    Node node = 2;
}

enum CardNodeAnchorPosition {
    CARD_NODE_ANCHOR_POSITION_UNSPECIFIED = 0;

    CARD_NODE_ANCHOR_POSITION_BOTTOM = 1;

    CARD_NODE_ANCHOR_POSITION_LEFT = 2;

    CARD_NODE_ANCHOR_POSITION_RIGHT = 3;
}

// Possible corners which can be anchored.
enum AnchorCorner {
    ANCHOR_CORNER_UNSPECIFIED = 0;
    ANCHOR_CORNER_TOP_LEFT = 1;
    ANCHOR_CORNER_TOP_RIGHT = 2;
    ANCHOR_CORNER_BOTTOM_LEFT = 3;
    ANCHOR_CORNER_BOTTOM_RIGHT = 4;
}

// Requests that a specific corner of a Node be anchored to a specific
// corner of a card.
message CardAnchor {
    AnchorCorner node_corner = 1;
    AnchorCorner card_corner = 2;
}

// Render an interface element attached to a specific card.
message CardAnchorNode {
    CardIdentifier card_id = 1;
    Node node = 2;
    CardNodeAnchorPosition anchor_position = 3;

    // Used to set the absolute position inset of 'node' to match corners of
    // the identified card. Later anchors in this list overwrite earlier
    // anchors in the case of a conflict.
    repeated CardAnchor anchors = 4;
}

message InterfaceMainControls {
    // Main controls area
    Node node = 1;

    // Controls for specific cards
    repeated CardAnchorNode card_anchor_nodes = 3;
}

// Updates the content of the user interface.
message RenderInterfaceCommand {
    // List of panels to update.
    //
    // A 'panel' is an independently addressable block of UI. The contents
    // of each known panel are cached and can then be opened immediately
    // via TogglePanelAction, without waiting for a server response.
    repeated InterfacePanel panels = 1;

    // Controls for game actions such as interface prompts
    InterfaceMainControls main_controls = 2;
}

// Opens or closes the given interface panel.
message TogglePanelCommand {
    PanelAddress panel_address = 1;
    // Should the panel be opened or closed?
    bool open = 2;
}

/* Updates the current GameView state. */
message UpdateGameViewCommand {
    GameView game = 1;
}

enum RoomVisitType {
    ROOM_VISIT_TYPE_UNSPECIFIED = 0;
    ROOM_VISIT_TYPE_INITIATE_RAID = 1;
    ROOM_VISIT_TYPE_LEVEL_UP_ROOM = 2;
}

/*
 * Animates 'initiator' moving to a room and plays a standard particle effect
 * based on the visit type.
 */
message VisitRoomCommand {
    PlayerName initiator = 1;
    RoomIdentifier room_id = 2;
    RoomVisitType visit_type = 3;
}

enum CardCreationAnimation {
    CARD_CREATION_ANIMATION_UNSPECIFIED = 0;

    /* Animates the card moving from the deck to the staging area. */
    CARD_CREATION_ANIMATION_DRAW_CARD = 1;

    // Animates the card moving from its parent card (indicated by its card
    // identifier with no 'ability_id') to its create position.
    CARD_CREATION_ANIMATION_FROM_PARENT_CARD = 2;
}

/*
 * Creates a new card, or updates an existing card if one is already present
 * with the provided CardId.
 *
 * When a user takes the 'draw card' game action, an optimistically-created
 * card is constructed and animated to the staging area face down. If an
 * optimistically-created card is found, that card is updated with the 'card'
 * value here instead.
 */
message CreateOrUpdateCardCommand {
    CardView card = 1;

    /*
     * Optionally, a position in which to create this card. Ignored if the card
     * already exists, if a 'create_animation' is specified, or during optimistic
     * card draw.
     */
    ObjectPosition create_position = 2;

    /*
     * Optionally, an animation to play after creating the card. Ignored if
     * the card already exists. Ignored during optimistic card draw.
     */
    CardCreationAnimation create_animation = 3;

    /*
    * Disables the flip animation for this card, allowing it immediately
    * transition to a revealed state.
    */
    bool disable_flip_animation = 4;
}

/*
 * Requests to destroy a card game object.
 */
message DestroyCardCommand {
    CardIdentifier card_id = 1;
}

/*
 * Moves a list of GameObjects to a new position.
 *
 * Objects already in the target position are skipped.
 */
message MoveGameObjectsCommand {
    repeated GameObjectIdentifier ids = 1;

    /*
     * Position at which to insert. If multiple ids are specified, each
     * additional object will be given a sorting key which is 1 greater than
     * the previous object's sorting key.
     */
    ObjectPosition position = 2;

    bool disable_animation = 3;
}

/*
 * Request to move all GameObjects located at a specific object position to
 * another object position.
 */
message MoveGameObjectsAtPositionCommand {
    ObjectPosition source_position = 1;

    ObjectPosition target_position = 2;

    bool disable_animation = 3;
}

message PlaySoundCommand {
    AudioClipAddress sound = 1;
}

enum MusicState {
    MUSIC_STATE_UNSPECIFIED = 0;
    MUSIC_STATE_SILENT = 1;
    MUSIC_STATE_GAMEPLAY = 2;
    MUSIC_STATE_RAID = 3;
}

message SetMusicCommand {
    MusicState music_state = 1;
}

/*
 * Fire a projectile from one game object at another.
 */
message FireProjectileCommand {
    GameObjectIdentifier source_id = 1;
    GameObjectIdentifier target_id = 2;

    /* Projectile to fire from the 'source_id' card to 'target_id' */
    ProjectileAddress projectile = 3;

    /* How long the projectile should take to hit its target. */
    TimeValue travel_duration = 4;

    AudioClipAddress fire_sound = 5;

    AudioClipAddress impact_sound = 6;

    /* Additional effect to display on the target on hit. */
    EffectAddress additional_hit = 7;

    /*
     * Delay before showing the additional hit. If provided, the original
     * projectile Hit effect will be hidden before showing the new hit effect.
     */
    TimeValue additional_hit_delay = 8;

    /*
     * During to wait for the project's impact effect before continuing
     */
    TimeValue wait_duration = 9;

    /*
     * If true, the target will be hidden after being hit during the
     * 'wait_duration' and before jumping to 'jump_to_position'.
     */
    bool hide_on_hit = 10;

    /*
     * Position for the target to jump to after being hit.
     */
    ObjectPosition jump_to_position = 11;
}

message PlayEffectPosition {
    oneof effect_position {
        GameObjectIdentifier game_object = 1;
    }
}

message PlayEffectCommand {
    EffectAddress effect = 1;

    PlayEffectPosition position = 2;

    google.protobuf.FloatValue scale = 3;

    /* How long to wait before continuing. */
    TimeValue duration = 4;

    AudioClipAddress sound = 5;
}

enum GameMessageType {
    GAME_MESSAGE_TYPE_UNSPECIFIED = 0;
    GAME_MESSAGE_TYPE_DAWN = 1;
    GAME_MESSAGE_TYPE_DUSK = 2;
    GAME_MESSAGE_TYPE_VICTORY = 3;
    GAME_MESSAGE_TYPE_DEFEAT = 4;
}

message DisplayGameMessageCommand {
    GameMessageType message_type = 1;
}

// Used to hide and show all game UI elements.
message SetGameObjectsEnabledCommand {
    bool game_objects_enabled = 1;
}

message DisplayRewardsCommand {
    repeated CardView rewards = 1;
}

enum SceneLoadMode {
    SCENE_LOAD_MODE_UNSPECIFIED = 0;
    // Close all currently open scenes before loading.
    SCENE_LOAD_MODE_SINGLE = 1;
    // Adds a scene to the current loaded scenes.
    SCENE_LOAD_MODE_ADDITIVE = 2;
}

// Loads a named Unity scene
message LoadSceneCommand {
    string scene_name = 1;
    SceneLoadMode mode = 2;
}

// Writes the PlayerIdentifier for the client to storage
message SetPlayerIdentifierCommand {
    PlayerIdentifier id = 1;
}

// Sets a client-side boolean player preference
message SetBooleanPreference {
    string key = 1;
    bool value = 2;
}

// Possible client logging levels
enum LogMessageLevel {
    LOG_MESSAGE_LEVEL_UNSPECIFIED = 0;
    LOG_MESSAGE_LEVEL_STANDARD = 1;
    LOG_MESSAGE_LEVEL_WARNING = 2;
    LOG_MESSAGE_LEVEL_ERROR = 3;
}

// Logs a client message
message LogMessage {
    string text = 1;
    LogMessageLevel level = 2;
}

// Activates client-side debugging functionality
message ClientDebugCommand {
    oneof debug_command {
        google.protobuf.Empty ShowLogs = 1;
        GameAction invoke_action = 2;
        LogMessage log_message = 3;
        SetBooleanPreference set_boolean_preference = 4;
    }
}

message GameCommand {
    oneof command {
        ClientDebugCommand debug = 1;
        RunInParallelCommand run_in_parallel = 2;
        DelayCommand delay = 3;
        ConnectToGameCommand connect_to_game = 4;
        RenderInterfaceCommand render_interface = 5;
        TogglePanelCommand toggle_panel = 6;
        UpdateGameViewCommand update_game_view = 7;
        VisitRoomCommand visit_room = 8;
        CreateOrUpdateCardCommand create_or_update_card = 9;
        DestroyCardCommand destroy_card = 10;
        MoveGameObjectsCommand move_game_objects = 11;
        MoveGameObjectsAtPositionCommand move_objects_at_position = 12;
        PlaySoundCommand play_sound = 13;
        SetMusicCommand set_music = 14;
        FireProjectileCommand fire_projectile = 15;
        PlayEffectCommand play_effect = 16;
        DisplayGameMessageCommand display_game_message = 17;
        SetGameObjectsEnabledCommand set_game_objects_enabled = 18;
        DisplayRewardsCommand display_rewards = 19;
        LoadSceneCommand load_scene = 20;
        SetPlayerIdentifierCommand set_player_id = 21;
    }
}

message CommandList {
    repeated GameCommand commands = 1;
}

service Spelldawn {
    /* Initiate a new server connection. */
    rpc Connect(ConnectRequest) returns (stream CommandList);

    /* Perform a game action. */
    rpc PerformAction(GameRequest) returns (CommandList);
}
